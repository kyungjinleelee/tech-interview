## Call By Value와 Call By Reference의 차이에 대해 설명해주세요.
특정 함수 호출할 때 인자를 전달하는 방법에는 크게 2가지가 존재합니다. 
- **Call by Value (값에 의한 호출)**
- **Call by Reference (참조에 의한 호출)**

Call By Value와 Call By Reference는 **값을 전달하는 방식**과 **메모리 사용 방식**에서 차이점이 존재합니다.

### Call by Value
- **값에 의한 호출**
- 함수에 인자를 전달할 때 인자값을 **복사**하여 전달하는 방식
- 원본 데이터와 전달된 복사본이 다른 메모리 주소를 갖기 때문에, 함수 내에서 값을 변경해도 원본 데이터에는 영향을 줄 수 없음
- 값을 복사하기 때문에 **메모리 사용량** 증가 ⭐
- ex) C, Java, Python

### Call by Reference
- **참조에 의한 호출**
- 함수에 인자를 전달할 때 인자의 **메모리 주소**를 **전달**하는 방식
- 해당 주소를 통해 원본 데이터를 **직접 수정**할 수 있음
- 별도 메모리를 사용하지 않고 주소만 참조 ⭐
- ex) C++, Swift, PHP

---

## 메모리 관점에서의 비교
### Call By Reference – 예시 (C++)
```c++
void change(int &x) {
    x = 10;
}

int main() {
    int a = 5;
    change(a);  // a가 5에서 10으로 바뀜
}

```
- a의 주소를 그대로 전달하여, 함수 내부에서 원본 값을 수정 가능
- 스택에는 주소만 복사됨 → 별도 메모리를 사용하지 않아 메모리 사용 효율적
- 메모리 오염 가능성 존재 → 실수에 주의 필요

<br>

### Call By Value – 예시 (Java)
```java
public void change(int x) {
    x = 10;
}

public void main() {
    int a = 5;
    change(a);  // a는 여전히 5
}
```
- a의 값 5가 복사되어 change()의 x에 전달됨
- x는 스택에 별도로 존재하는 변수
- 메모리 측면에서 값 복사가 발생 → 원본 보호됨, 하지만 메모리 사용량 증가

---

## 요약

| 항목 | Call By Value (값에 의한 호출) | Call By Reference (참조에 의한 호출) |
|------|-----------------------------|-----------------------------------|
| **전달 방식** | 인자의 **값 자체를 복사**해서 전달 | 인자의 **주소(참조)를 전달** |
| **원본 데이터 변경** | 함수 내부에서 변경해도 **원본은 영향 없음** | 함수 내부에서 변경하면 **원본도 변경됨** |
| **스택 메모리 사용** | 함수 호출 시, **복사된 값**이 스택 프레임에 저장됨 | **참조값(주소)** 하나만 저장됨 |
| **힙 메모리 사용** | 객체는 여전히 힙에 있으나, 함수는 복사된 참조를 받음 | 같은 힙 객체를 공유함 |
| **메모리 사용량** | 복사 비용 발생 (특히 값이 크면 부담됨) | 주소만 전달 → 메모리 사용량이 적음 |
| **안전성** | 원본 데이터가 보호됨 (불변성 유지 용이) | 원본 데이터가 쉽게 변경됨 (주의 필요) |
| **사용 예시 언어** | Java, C (기본적으로) | C++ (포인터), Python (일부 동작), Go (포인터 사용) |

---
### 꼬리 질문
- [자바가 Call by Value 방식인 이유]()
  
### 참고 자료
- [프로그래밍에서의 Call by Value와 Call by Reference 이해하기](https://f-lab.kr/insight/understanding-call-by-value-and-reference)
- ['Call by value'와 'Call by reference'의 차이](https://moondongjun.tistory.com/70)
